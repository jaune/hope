// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TILEINDEXES_HOPE_SAMPLES_TOY_FBS_H_
#define FLATBUFFERS_GENERATED_TILEINDEXES_HOPE_SAMPLES_TOY_FBS_H_

#include "flatbuffers/flatbuffers.h"


namespace hope {
namespace samples {
namespace toy {
namespace fbs {

struct TileIndex8;
struct TileIndex4;
struct TileIndexes;

enum TileType {
  TileType_VOID = 0,
  TileType_WALL = 1,
  TileType_FLOOR = 2,
  TileType_DOOR = 3
};

inline const char **EnumNamesTileType() {
  static const char *names[] = { "VOID", "WALL", "FLOOR", "DOOR", nullptr };
  return names;
}

inline const char *EnumNameTileType(TileType e) { return EnumNamesTileType()[e]; }

struct TileIndex8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int8_t index() const { return GetField<int8_t>(4, 0); }
  TileType center() const { return static_cast<TileType>(GetField<int8_t>(6, 0)); }
  TileType top() const { return static_cast<TileType>(GetField<int8_t>(8, 0)); }
  TileType topright() const { return static_cast<TileType>(GetField<int8_t>(10, 0)); }
  TileType right() const { return static_cast<TileType>(GetField<int8_t>(12, 0)); }
  TileType bottomright() const { return static_cast<TileType>(GetField<int8_t>(14, 0)); }
  TileType bottom() const { return static_cast<TileType>(GetField<int8_t>(16, 0)); }
  TileType bottomleft() const { return static_cast<TileType>(GetField<int8_t>(18, 0)); }
  TileType left() const { return static_cast<TileType>(GetField<int8_t>(20, 0)); }
  TileType topleft() const { return static_cast<TileType>(GetField<int8_t>(22, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* index */) &&
           VerifyField<int8_t>(verifier, 6 /* center */) &&
           VerifyField<int8_t>(verifier, 8 /* top */) &&
           VerifyField<int8_t>(verifier, 10 /* topright */) &&
           VerifyField<int8_t>(verifier, 12 /* right */) &&
           VerifyField<int8_t>(verifier, 14 /* bottomright */) &&
           VerifyField<int8_t>(verifier, 16 /* bottom */) &&
           VerifyField<int8_t>(verifier, 18 /* bottomleft */) &&
           VerifyField<int8_t>(verifier, 20 /* left */) &&
           VerifyField<int8_t>(verifier, 22 /* topleft */) &&
           verifier.EndTable();
  }
};

struct TileIndex8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int8_t index) { fbb_.AddElement<int8_t>(4, index, 0); }
  void add_center(TileType center) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(center), 0); }
  void add_top(TileType top) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(top), 0); }
  void add_topright(TileType topright) { fbb_.AddElement<int8_t>(10, static_cast<int8_t>(topright), 0); }
  void add_right(TileType right) { fbb_.AddElement<int8_t>(12, static_cast<int8_t>(right), 0); }
  void add_bottomright(TileType bottomright) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(bottomright), 0); }
  void add_bottom(TileType bottom) { fbb_.AddElement<int8_t>(16, static_cast<int8_t>(bottom), 0); }
  void add_bottomleft(TileType bottomleft) { fbb_.AddElement<int8_t>(18, static_cast<int8_t>(bottomleft), 0); }
  void add_left(TileType left) { fbb_.AddElement<int8_t>(20, static_cast<int8_t>(left), 0); }
  void add_topleft(TileType topleft) { fbb_.AddElement<int8_t>(22, static_cast<int8_t>(topleft), 0); }
  TileIndex8Builder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileIndex8Builder &operator=(const TileIndex8Builder &);
  flatbuffers::Offset<TileIndex8> Finish() {
    auto o = flatbuffers::Offset<TileIndex8>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<TileIndex8> CreateTileIndex8(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t index = 0,
   TileType center = TileType_VOID,
   TileType top = TileType_VOID,
   TileType topright = TileType_VOID,
   TileType right = TileType_VOID,
   TileType bottomright = TileType_VOID,
   TileType bottom = TileType_VOID,
   TileType bottomleft = TileType_VOID,
   TileType left = TileType_VOID,
   TileType topleft = TileType_VOID) {
  TileIndex8Builder builder_(_fbb);
  builder_.add_topleft(topleft);
  builder_.add_left(left);
  builder_.add_bottomleft(bottomleft);
  builder_.add_bottom(bottom);
  builder_.add_bottomright(bottomright);
  builder_.add_right(right);
  builder_.add_topright(topright);
  builder_.add_top(top);
  builder_.add_center(center);
  builder_.add_index(index);
  return builder_.Finish();
}

struct TileIndex4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int8_t index() const { return GetField<int8_t>(4, 0); }
  TileType center() const { return static_cast<TileType>(GetField<int8_t>(6, 0)); }
  TileType top() const { return static_cast<TileType>(GetField<int8_t>(8, 0)); }
  TileType right() const { return static_cast<TileType>(GetField<int8_t>(10, 0)); }
  TileType bottom() const { return static_cast<TileType>(GetField<int8_t>(12, 0)); }
  TileType left() const { return static_cast<TileType>(GetField<int8_t>(14, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* index */) &&
           VerifyField<int8_t>(verifier, 6 /* center */) &&
           VerifyField<int8_t>(verifier, 8 /* top */) &&
           VerifyField<int8_t>(verifier, 10 /* right */) &&
           VerifyField<int8_t>(verifier, 12 /* bottom */) &&
           VerifyField<int8_t>(verifier, 14 /* left */) &&
           verifier.EndTable();
  }
};

struct TileIndex4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int8_t index) { fbb_.AddElement<int8_t>(4, index, 0); }
  void add_center(TileType center) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(center), 0); }
  void add_top(TileType top) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(top), 0); }
  void add_right(TileType right) { fbb_.AddElement<int8_t>(10, static_cast<int8_t>(right), 0); }
  void add_bottom(TileType bottom) { fbb_.AddElement<int8_t>(12, static_cast<int8_t>(bottom), 0); }
  void add_left(TileType left) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(left), 0); }
  TileIndex4Builder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileIndex4Builder &operator=(const TileIndex4Builder &);
  flatbuffers::Offset<TileIndex4> Finish() {
    auto o = flatbuffers::Offset<TileIndex4>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<TileIndex4> CreateTileIndex4(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t index = 0,
   TileType center = TileType_VOID,
   TileType top = TileType_VOID,
   TileType right = TileType_VOID,
   TileType bottom = TileType_VOID,
   TileType left = TileType_VOID) {
  TileIndex4Builder builder_(_fbb);
  builder_.add_left(left);
  builder_.add_bottom(bottom);
  builder_.add_right(right);
  builder_.add_top(top);
  builder_.add_center(center);
  builder_.add_index(index);
  return builder_.Finish();
}

struct TileIndexes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<TileIndex4>> *indexes4() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileIndex4>> *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<TileIndex8>> *indexes8() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileIndex8>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* indexes4 */) &&
           verifier.Verify(indexes4()) &&
           verifier.VerifyVectorOfTables(indexes4()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* indexes8 */) &&
           verifier.Verify(indexes8()) &&
           verifier.VerifyVectorOfTables(indexes8()) &&
           verifier.EndTable();
  }
};

struct TileIndexesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indexes4(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileIndex4>>> indexes4) { fbb_.AddOffset(4, indexes4); }
  void add_indexes8(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileIndex8>>> indexes8) { fbb_.AddOffset(6, indexes8); }
  TileIndexesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileIndexesBuilder &operator=(const TileIndexesBuilder &);
  flatbuffers::Offset<TileIndexes> Finish() {
    auto o = flatbuffers::Offset<TileIndexes>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<TileIndexes> CreateTileIndexes(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileIndex4>>> indexes4 = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileIndex8>>> indexes8 = 0) {
  TileIndexesBuilder builder_(_fbb);
  builder_.add_indexes8(indexes8);
  builder_.add_indexes4(indexes4);
  return builder_.Finish();
}

inline const TileIndexes *GetTileIndexes(const void *buf) { return flatbuffers::GetRoot<TileIndexes>(buf); }

inline bool VerifyTileIndexesBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<TileIndexes>(); }

inline void FinishTileIndexesBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<TileIndexes> root) { fbb.Finish(root); }

}  // namespace fbs
}  // namespace toy
}  // namespace samples
}  // namespace hope

#endif  // FLATBUFFERS_GENERATED_TILEINDEXES_HOPE_SAMPLES_TOY_FBS_H_
